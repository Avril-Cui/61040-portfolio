# 1. Concept Questions
## Contexts
The NonceGeneration concept ensures that the short strings it generates will be unique and not result in conflicts. What are the contexts for, and what will a context end up being in the URL shortening app?

The contexts in the NonceGeneration concept is used to define which scope we are requiring uniqueness for. In particular, instead of requiring every generated string to be unique across the entire system, uniqueness only needs to hold within a given context.

In an URL shortening app, a context will be a domain or a base URL under which the shortened links are created. For example:
- Within tinyurl.com, all nonces must be unique. We cannot have two tinyurl.com/abc
- The same nonce (/abc) can exist under two contexts without conflict. We can have both tinyurl.com/abc and mydomain.com/abc

## Storing using strings
Why must the NonceGeneration store sets of used strings? One simple way to implement the NonceGeneration is to maintain a counter for each context and increment it every time the generate action is called. In this case, how is the set of used strings in the specification related to the counter in the implementation? (In abstract data type lingo, this is asking you to describe an abstraction function.)

It is necessary for NonceGeneration to store sets of used strings because the concept maintains an invariant that each generated nonce must be a string not used before for that context. To enforce this invariant, the context must remember ALL the strings it has already generated. So, we need some way to store or note those used strings for each context.

A simple implementation could just maintain a counter for each context that starts at 0 and increments with each `generate` call. The counter acts as the way to "remember used strings." Each time when the system is asked to generate a new nonce (i.e., when `generate` is called), it will:

1. Convert the current counter value into a string (the easiest way is $0\to$ "0", $1\to$ "1", ...)
2. Increment the counter for the context


So, the set of strings in the specification is implemented with the counter.

## Words as nonces
One option for nonce generation is to use common dictionary words (in the style of yellkey.com, for example) resulting in more easily remembered shortenings. What is one advantage and one disadvantage of this scheme, both from the perspective of the user? How would you modify the NonceGeneration concept to realize this idea?

### Advantage
It is much easier to remember, say, and type shortened URL with dictionary words as suffixes. Usually, people want to shorten URL so that they can share this link with others more easily. A short link with dictionary words suffixes makes the link more human-readable and shareable in conversation.

### Disadvantage
There is a limited number of short and common dictionary words. If the system runs out of short and simple words, it could use long, complex words (e.g., sesquipedalian). These words can be difficulty to read out, type out, or remember exactly.

### NonceGeneration modification
We modify NonceGeneration to realize this idea.

```
concept NonceGeneration [Context, Dictionary]
purpose
    generate unique string of a dictionary word within a context
principle
    each generate returns a word or word phrase not returned before for that context
state
a set of Contexts with
    a used set of Strings
    a dictionary Dictionary
actions
    generate (context: Context) : (nonce: String)
        requires: exists at least one unused phrase in the dictionary
        effect: returns a word from the dictionary that is not already used by this context
```

# 2. Synchronizations for URL Shortening

## Partial matching
In the first sync (called generate), the Request.shortenUrl action in the when clause includes the shortUrlBase argument but not the targetUrl argument. In the second sync (called register) both appear. Why is this?

In the `generate` sync, its purpose is to ask NonceGeneration to make a unique nonce in the given concept. Therefore, the only argument needed to generate this nonce is the shortUrlBase, which will be the context. The targetUrl isn't used in NonceGeneration at all, so it is omitted to preserve separation of concepts.

In the `register` sync, our purpose is to register a shortenUrl given a shortUrlBase and a nonce, and associate this shortenURL with a targetUrl. So, we need the full set of information for registration.

## Omitting names
Omitting names. The convention that allows names to be omitted when argument or result names are the same as their variable names is convenient and allows for a more succinct specification. Why isn’t this convention used in every case?

To maintain modularity and separation of concerns, we could use different names in different concepts when referring to the same thing. For example, the `nonce` generated by NonceGeneration and the `shortUrlSuffix` in UrlShortening are the same thing in the `register` sync. If we follow the convention and omit the names, we will result in ambiguity (i.e., which name do we use? nonce or shortUrlSuffix?) and lost track of the connection between variables like nonce and shortUrlSuffix.  By keeping both argument and result names visible, we maintain the modularity goal of keeping responsibilities explicit while making it clear that two concept interact.

## Inclusion of request
Inclusion of request. Why is the request action included in the first two syncs but not the third one?

The sync `generate` is triggered by a user request to shorten a URL. Similarly, the sync `register` is trigged by a user request to shorten URL, but now it also waits until NonceGeneration has produced a nonce. Both syncs exist to response to some external input requested by a user.

On the other hand, the sync `setExpiry` is triggered by the completion of another concept's action (i.e., UrlShortening.register). No user request is needed because we want the `setExpiry` sync to be an automatic system follow-up after any URL is registered. This is why we do not include the `request` action as it is not associated with a user action or request.

## Fixed domain
Suppose the application did not support alternative domain names, and always used a fixed one such as “bit.ly.” How would you change the synchronizations to implement this?

We modify the `generate` and `register` syncs. Instead of passing in ShortUrlBase as a variable input in the request, we fix it to some predefined value. For demonstration, we set it as "bit.ly":

```
sync generate
    when Request.shortenUrl ()
    then NonceGeneration.generate (context: "bit.ly")

sync register
    when
        Request.shortenUrl (targetUrl)
        NonceGeneration.generate (): (nonce)
    then UrlShortening.register (shortUrlSuffix: nonce, shortUrlBase: "bit.ly", targetUrl)
```

## Adding a sync
Adding a sync. These synchronizations are not complete; in particular, they don’t do anything when a resource expires. Write a sync for this case, using appropriate actions from the ExpiringResource and URLShortening concepts.

```
sync expireShortUrl
    when ExpiringResource.expireResource (): (resource)
    then UrlShortening.delete (shortUrl: resource)
```
<!-- because ExpiringResource.setExpiry is a system action performed spontaneously when its precondition is true.  -->


# Extending the design
We first define some additional concepts.
## ShortUrlOwnership 

```
concept: ShortUrlOwnership [User, shortUrl]

purpose:
    record which user registered each short URL

principle:
    after a short URL is registered, its owner is set as the user who registered it

state:
    a set of Ownerships with
        a shortUrl
        an owner User

actions
    assign(shortUrl: shortUrl, owner: User)
        requires: no ownership exists for shortUrl
        effect: records owner for shortUrl

    getOwner(shortUrl: shortUrl): (owner: User)
        requires: ownership exists for shortUrl
        effect: returns the owner
    
    authorize(hortUrl: shortUrl, user: User):
        requires: ownership exists for shortUrl and user matches the owner
        effect: approves authorization
```

## AnalyticsCounts
```
concept: AnalyticsCounts [shortUrl]

purpose:
    provide analytics to track how many times each URL is accessed

principle:
    after initializing a counter for a short URL, each successful redirection of that short URL to its target increase its count

state
    a set of Counters with
        a shortURL
        a count Number
    
actions
    initCount(shortUrl: shortUrl)
        requires: no counter exists for shortUrl
        effect: creates a counter for shortUrl with count = 0
    
    increment(shortUrl: shortUrl)
        requires: counter exists for shortUrl
        effect: increase count by 1
    
    getCount(shortUrl: shortUrl): (count: Number)
        requires: counter exists for shortUrl
        effect: return the current count
```

Next, we specify three important synchronizations with the new concepts.

Specify three essential synchronizations with your new concepts: one that happens when shortenings are created; one when shortenings are translated to targets; and one when a user examines analytics.

### When shortening are created
```
sync initAnalytics

when:
    Request.shortenUrl(targetUrl, shortUrlBase, user)
    NonceGeneration.generate (): (nonce)
    UrlShortening.register (shortUrlSuffice: nonce, shortUrlBase, targetUrl): (shortUrl)

then:
    // assign the ownership of the shortUrl
    ShortUrlOwnerShip.assign (shortUrl, owner: user)
    // init the counter of the shortUrl
    AnalyticsCounts.initCount (shortUrl)
```

### When shortening are translated to targets
// check this one to see where to get shortUrl (request?)
```
sync recordAccess

when:
    Request.accessShortUrl (shortUrl)
    UrlShortening.lookup (shortUrl): (targetUrl)

then:
    AnalyticsCounts.increment (shortUrl)
```

### When a user examines analytics
```
sync viewAnalytics

when:
    Request.viewAnalytics (shortUrl, user)
    ShortUrlOwnership.authorize(shortUrl, user)

then:
    AnalyticsCounts.getCount(shortUrl): (count)
```

Finally, we outline how each feature requests will get realized.

### Allowing users to choose their own short URLs
We can achieve this by adding a new `registerCustom` sync, and a new action `verifySuffix` under NonceGeneration.

```
// in NonceGeneration

actions
    customSuffix (context: Context, nonce: String)
        requires: nonce is not already used by this context
        effects: passes verification and add nonce to context
```

```
sync registerCustom

when:
    Request.shortenUrlCustomSuffix (targetUrl, shortUrlBase, shortUrlSuffix, user)
    NonceGeneration.verifySuffix (context: shortUrlBase, nonce: shortUrlSuffix)

then:
    UrlShortening.register (shortUrlSuffix, shortUrlBase, targetUrl): (shortUrl)
    ShortUrlOwnership.assign(shortUrl, owner: user)
    AnalyticsCounts.initCount(shortUrl)
```

<!-- We can achieve this by adding a new `registerCustom` action under UrlShortening. 

```
// in UrlShortening
actions
    registerCustom (shortUrlBase, )

``` -->

## Using the “word as nonce” strategy to generate more memorable short URLs
We generate a new concept called `WordNonceGeneration`, like how we specify it in Part 1 previously:

```
concept WordNonceGeneration [Context, Dictionary]
purpose
    generate unique string of a dictionary word within a context
principle
    each generate returns a word or word phrase not returned before for that context
state
a set of Contexts with
    a used set of Strings
    a dictionary Dictionary
actions
    generate (context: Context) : (nonce: String)
        requires: exists at least one unused phrase in the dictionary
        effect: returns a word from the dictionary that is not already used by this context
```

Now, we can have syncs `generateMemorable` and `registerMemorable` for more memorable short URLs:

```
sync generateMemorable

when:
    Request.shortenUrlMemorable(targetUrl, shortUrlBase)

then:
    WordNonceGeneration.generate(context: shortUrlBase)


sync registerMemorable

when:
    Request.shortenUrlMemorable(targetUrl, shortUrlBase, user)
    WordNonceGeneration.generate(): (nonce)

then:
    UrlShortening.register(shortUrlSuffix: nonce, shortUrlBase, targetUrl): (shortUrl)
    ShortUrlOwnership.assign(shortUrl, owner: user)
    AnalyticsCounts.initCount(shortUrl)
```

## Including the target URL in analytics
Including the target URL in analytics, so that lookups of different short URLs can be grouped together when they refer to the same target URL;

For the purpose of separation of concerns, we create an TargetAnalyticsCounts concept, which is the same as AnalyticsCount, but instead of having a shortUrl and a count under Counters, we have a targetUrl and a count under the set of Counters:
```
concept: TargetAnalyticsCounts [TargetUrl]

purpose:
    provide analytics to track how many times each URL is accessed

principle:
    after initializing a counter for a short URL, each successful redirection of that short URL to its target increase its count

state
    a set of Counters with
        a targetUrl TargetUrl
        a count Number
    
actions
    initCount(targetUrl: TargetUrl)
        requires: no counter exists for targetUrl
        effect: creates a counter for targetUrl with count = 0
    
    increment(targetUrl: TargetUrl)
        requires: counter exists for targetUrl
        effect: increase count by 1
    
    getCount(targetUrl: TargetUrl): (count: Number)
        requires: counter exists for targetUrl
        effect: return the current count
```

Then, we add a sync with `UrlShortening.register` to initialize the targetUrl counter if the target does not have a counter yet, a sync with `UrlShortening.lookup` to increment the count of the ShortUrl and the targetUrl.

```
sync initAnalytics

when:
    Request.shortenUrl(targetUrl, shortUrlBase, user)
    NonceGeneration.generate (): (nonce)
    UrlShortening.register (shortUrlSuffice: nonce, shortUrlBase, targetUrl): (shortUrl)

then:
    // assign the ownership of the shortUrl
    ShortUrlOwnerShip.assign (shortUrl, owner: user)
    // init the counter of the shortUrl
    AnalyticsCounts.initCount (shortUrl)
    // init the counter of the baseUrl (the precondition will check if the targetUrl already has a counter)
    TargetAnalyticsCounts.initCount (targetUrl)


sync recordAccess

when:
    Request.accessShortUrl (shortUrl)
    UrlShortening.lookup (shortUrl): (targetUrl)

then:
    AnalyticsCounts.increment (shortUrl)
    TargetAnalyticsCounts.increment (targetUrl)


sync viewTargetAnalytics

when:
    Request.viewTargetAnalytics (targetUrl)

then:
    TargetAnalyticsCounts.getCount(targetUrl): (count)
```

However, we can see a caveat in the `viewTargetAnalytics` sync. Different users can generate multiple shortUrls that directs to the same targetUrl. This is problematic because the prompt specified that: "Analytics should not be public but should be viewable only by the user who registered the shortening." Thus, we probably should not include this feature of viewing target URL analytics due to privacy concerns.

## Generate short URLs that are not easily guessed
To achieve this feature, we simply modify the `generate` action in NonceGeneration so that instead of returning any nonce that is not already used by the context, we return some secure nonce (perhaps generated by cryptographic encryption algorithms) that are not used by this context. We also see that this feature can contradict with feature 2, because it's difficult to both achieve memorable words and security for nonces.

<!-- We make the following modification of the NonceGeneration concept: -->
<!-- ```
concept: NonceGeneration [Context]

purpose: generate unique strings within a context

principle:
    each generate returns a string not returned before for that context

state:
    a set of Contexts with
        a used set of Strings
    
actions:
    generate (context: Context) : (nonce: String)
        effect returns a nonce that is not already used by this context
    
    generate (context: Context) : (nonce: String)
        effect:
            generates a random string of alphabets
``` -->

## Supporting reporting of analytics to creators of short URLs who have not registered as user
I think this feature is undesirable and should not be included. The current analytics concept design is based on the core that "Analytics should not be public but should be viewable only by the user who registered the shortening." Letting non-registered creators view analytics weakens that privacy model and conflates identity authentication with analytics.












